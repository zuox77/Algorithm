# Binary Search 总结
## 二分算法是为了解决什么问题
为了能在有序数组里, 通过`O(logN)`的时间复杂度, 找到某个值, 或者某个值的下标
更确切的说, 是通过`O(logN)`的时间复杂度缩小范围
## 二分算法的公式
1. 定义`left`和`right`指针: 这两个指针都代表的是数组的下标, 而不是具体的数值
1. `left`指针会指向数组的左端 (即下标`0`的位置), `right`指针会指向数组的右端 (即下标`n-1`的位置)
1. 通过`(left + right) / 2`计算出下标的中间值`mid`
1. 比较数组中`mid`所在的位置的数的数值, 与`target`之间的大小: 
   1. 如果`nums[mid] > target`, 那么将`right`指针移动到`mid`, 即`right = mid`
   1. 如果`nums[mid] < target`, 那么将`left`指针移动到`mid`, 即`left = mid`
   1. 如果`nums[mid] = target`, 那么答案已经找到, 要么返回该值, 要么根据题意做其他处理
#### 公式搭配一
```
// 定义指针
int left = 0, right = n - 1;
// while循环遍历
while (left + 1 < right) {
   int mid = left + (right - left) / 2; // 等于: (left + right) / 2, 只不过这样写可以避免left和right都是很大的数值从而超过int的限制
   // 分情况判断指针如何移动
   // 找到答案, 直接返回
   if (nums[mid] == target) {
      return mid;
   // 比target小, 说明答案在右侧, 所以左指针往右移动
   } else if (nums[mid] < target) {
      left = mid;
   // 比target大, 说明答案在左侧, 所以右指针往左移动
   } else {
      right = mid;
   }
}
// 用这个方法会将答案缩小到left和right指针最后的位置, 所以需要再判断一次
if (nums[left] == target) {
   return left;
} else {
   return right;
}
// 没找到答案, 返回异常值
return -1;
```
#### 公式搭配二
```
// 定义指针
int left = 0, right = n - 1;
// while循环遍历
while (left <= right) { // 与搭配一不同, 这里是left <= right
   int mid = left + (right - left) / 2; // 等于: (left + right) / 2, 只不过这样写可以避免left和right都是很大的数值从而超过int的限制
   // 分情况判断指针如何移动
   // 找到答案, 直接返回
   if (nums[mid] == target) {
      return mid;
   // 比target小, 说明答案在右侧, 所以左指针往右移动
   } else if (nums[mid] < target) {
      left = mid + 1; // 与搭配一不同, 这里要加一
   // 比target大, 说明答案在左侧, 所以右指针往左移动
   } else {
      right = mid;
   }
}
// 因为是left <= right作为while循环的判断值, 所以不需要额外判断一次
// 没找到答案, 返回异常值
return -1;
```
## 二分算法详解
### 为什么一定要是有序数组
因为二分算法是通过: 比较数组`mid`位置上的数的数值与`target`之间的关系来判断如何二分并舍弃其中一半的数, 
如果不是有序数组, 那么无法通过排序来判断范围
### 二分法题型
1. 数组无重复值, 求`target`的位置
2. 数组有重复值, 求`target`首次出现的位置, 或者最后出现的位置, 或者都要
3. 其他变形题
### 二分法公式里, while循环的不同写法
二分公式里, 循环语句的三种写法:

|   | 代码                       |跳出循环前最后一次, 左右指针的位置关系(left )|循环退出时, 左右指针的位置|
|---|--------------------------|--------------------------|-|
| 1 | `while left < right`或者`while left + 1 <= right`   | 相邻时运行最后一次                |相等时退出循环, 指针相等|
| 2 | `while left <= right`    | 相等时运行最后一次                |错开时退出循环, 指针错位|
| 3 | `while left + 1 < right` | 差一格相邻时运行最后一次             |相邻时退出循环, 指针相邻|
### 二分法公式里, 移动指针的的不同写法

|   |移动左指针|移动右指针|
|---|-|-|
| 1 | `left = mid`|`right = mid`|
| 2 | `left = mid + 1` | `right = mid - 1`或者`right = mid` |
### 循环语句和移动指针如何配合使用
1. 循环语句1或者2: 必须配合移动指针2使用
2. 循环语句3: 必须配合移动指针1使用
### 推荐用法
1. 如果原数组中没有重复的数, 且不是二维矩阵: 推荐用搭配2, 即循环语句3 + 移动指针1   
   原因是在搭配1中, 需要用到移动指针2, 而移动指针2里面移动右指针有两种方式, 有的时候只能用right = mid, 而有的时候又只能用right = mid - 1, 容易出错   
   现在暂时没有发现其他的规律可以归纳总结为什么只能用right = mid或者为什么只能用right = mid - 1
2. 如果有重复的数或者是二维矩阵: 还是推荐用搭配1, 即循环语句1/2 + 移动指针2   
   但具体该用循环语句1还是循环语句2, 移动右指针该不该mid - 1, 就需要自己额外判断了
### while循环和移动指针的的不同写法有什么区别, 为什么要搭配使用
#### 为什么循环语句1或者2必须配合移动指针2使用
1. 二分算法最需要注意的问题是, 计算中间值`mid`时, 因为下标不能为小数, 所以用的都是整除, 但是整除会损失精度, 损失精度会导致, 当左右指针相邻时, 无论算多少次, `mid`都一定等于`left`, 因为整除默认是向下取整, 比如`(2 + 3) / 2 = 2`
1. 所以当下面3个条件同时出现时, 会陷入无限循环: 
   1. 左右指针相邻
   2. `if`判断语句的结果会使得`left`指针移动(`right`指针移动不影响结果, 因为整除是向下去整)
   3. 迭代语句用的是`left = mid`  
> 比如`left = 2`, `right = 3`, `mid = (2 + 3) / 2 = 2`  
> 1. `if`判断语句使得`left`移动, 即`left = mid = 2`  
> 1. `left = 2`, `right = 3`, `mid = (2 + 3) / 2 = 2`  
> 1. `if`判断语句使得`left`移动, 即`left = mid = 2`  
> 1. `left`一直等于2  
> --> 无限循环
3. 注意, 如果`if`判断语句的结果能使得`right`指针移动, 则无所谓
> 比如`left = 2`, `right = 3`, `mid= (2 + 3) / 2 = 2`  
> `if`判断语句使得`right`移动, 即`right = mid = 2`  
> `right`从3变成2
> --> 跳出循环
#### 为什么循环语句3必须配合移动指针1使用
1. 使用循环语句3的本质是, 当左右指针相邻时就退出循环, 意味着退出循环时, 并没有找到最后`target`的位置, 只是将范围缩小到了两个数, 即`left`指针和`right`指针最后退出循环时的两个数, 所以此时还需要额外对退出循环后的左右指针做一次判断
2. 如果循环语句3配合迭代语句2一起使用:   
   当运行到`while循环`退出前一次 (即`left`和`right`中间还隔着一个数, 比如`left = 1`, `right = 3`)的时候
   1. 如果此时`left`和`right`仍旧没有找到`target`, (即`nums[left] != target`, 且`nums[right] != target`), 则说明要么`target`在`mid`位置, 要么`target`不存在 
   2. 如果`target`在`mid`位置, 比如`left = 1`, `right = 3`, `mid = 2`, 则移动指针语句`left = mid + 1`会将`left`变成3 (即`right`的位置), 
      或者将right变成1(即left的位置), 然后退出循环, 此时已经错失了正确答案
> 搭配1, 即循环语句1/2配合移动指针2使用 
> 
> 例子: [5, 7, 7, 8, 8, 10], target = 8, 找target第一个位置  
> 下标: [0, 1, 2, 3, 4, 5]
> 代码如下: 
```
while (left <= right) {
   int mid = (left + right) / 2;
   if (nums[mid] < target) {
      left = mid + 1; -> 这种情况里, target相等时, right指针变化, 所以只需要保证left指针变化时额外加1即可
   } else {
      right = mid;
   }
}
 ```

> 搭配
> 例子: [5, 7, 7, 8, 8, 10], target = 8, 找target第一个位置
> 下标: [0, 1, 2, 3, 4, 5]
> 代码如下: 
```
while (left <= right) {
   int mid = (left + right) / 2;
   if (nums[mid] > target) {
      right = mid;
   } else {
      left = mid + 1;
   }
}
// 这种情况里, target相等时, left指针变化, 所以只需要保证left指针变化时额外加1即可
```

在数列中有相同的数值的题, 并要找`last position`或者`first position`时: 
> 例如 target = 3  
> index = [0, 1, 2, 3, 4, 5, 6]  
> list1 = [1, 2, 3, 3, 3, 4, 7]  
> list2 = [1, 2, 3, 4, 4, 5, 9]  
> 
> 如果是循环语句1或者2配合移动指针1写:   
> 当`list1[mid] == target`时, 因为不知道此时是不是第一个或者最后一个, 不能直接`return`
> 所以判断条件只能为: 
> ```
> if (list1[mid] == target) {
>     left(或者right) = mid;
>   }
> ```
> 而又因为整除会丢失精度, 所以当`left`和`right`相邻时, 算出来的`mid`永远等于`left` (例如`(3 + 4) // 2 = 3`)
  所以会陷入无限循环 
> 
> 如果是循环语句1或者2配合移动指针2写:   
> 则如果此时已经是第一个或者最后一个, 就会错失答案
> ```
> if (list1[mid] == target) {
>   left(或者right) = mid + 1;
> }
> ```
> 此时`left = 3`, 指向数字4的第一个