package DataStructure;
import java.util.Stack;
/*
https://leetcode.cn/problems/largest-rectangle-in-histogram/
https://www.lintcode.com/problem/122/
https://www.jiuzhang.com/problem/largest-rectangle-in-histogram/

思路：单调栈
单调栈的目的：在暴力解法中，我们计算方式是：对每一个数，再内循环一次找到其可能的最大宽度(向左右遍历直到遇到第一个比自己小的数停止)，即找到左右边界，
    在单调栈中利用递增和存储曾经出现过的数的特性，完成了暴力解法中的找寻宽度的左右边界的问题，即：
    每当想要进栈的数小于当前的栈顶，说明此时我们已经遍历到了当前栈顶的右边界，所以我们可以开始计算以当前栈顶
    为高的长方形的最长宽度是多少。又已知是单调栈且单调递增，所以当前栈顶的前一个数，是比当前栈顶小的数里面最大的数，即左边界，所以能算出面积
1. 栈里面存储的是数字的下标！
2. 此题最重要的点在于计算宽度。当一个数过高的时候，我们知道它的宽大概率为1，因为无法在原数组中向左右两边延伸形成长方形，而当一个数
    比较小时，则宽度就非常重要，比如1，理论来讲1的宽度可以横跨整个数组，它的面积是nums.length * 1，所以怎么判断某一个数的最大宽度是核心问题
3. 宽度计算公式：i - stack.peek() - 1的具体含义是：
    i是当前循环到原数组的哪个数了，又因为此数想要进栈，所以此数一定是当前栈顶的右边界，i = 当前栈顶能形成的长方形的右边界
    stack.peek()，理论上是栈顶值，但由于之前我们已经将当前栈顶pop出来了，所以其实是当前栈顶(top)的前一个数(newTop)，也就是左边界
    - 1，因为我们计算的时候，左右边界，其实是不包含在内的，即一个开区间(stack.peek(), i)而不是闭区间[stack.peek(), i]，所以-1获得正确的宽度
5. 其次要想清楚的是：栈顶左右两边的数，不一定是按原数组中的顺序排列的，所以计算宽度时，不是只计算原数组相邻两个数，而是代表的左边界和右边界
6. 一个例子过一遍：
    数组 [3, 2, 6, 7, 5, 3, 4]
    下标  0  1  2  3  4  5  6
    1. 3的下标0进栈
    2. 2的下标1进栈，2比3小，所以3pop出去，计算面积得1 * 3 = 3，更新最大面积变量
    3. 6的下标2进栈
    4. 7的下标3进栈
    5. 5的下标4进栈，5比7小，所以7pop出去，计算面积得1 * 7 = 7，更新最大面积变量
    6. 5也比6小，所以6继续pop出去，计算面积得2 * 6 = 12，更新最大面积变量
    7. 5比2大，5的下标4成功进栈，栈内的数是：[1, 4]，因为是下标所以实际的数是：[2, 5]
        这里也证明上面所说：栈顶左右两边的数，不一定是按原数组中的顺序排列的
    8. 3的下标5进栈，3比5小，所以5pop出去，计算面积得3 * 5 = 15，更新最大面积变量
    9. 3比2大，所以3的下标5成功进栈，栈内的数是：[1, 5]，因为是下标所以实际的数是：[2, 3]
    10. 4的下标6进栈，栈内的数是：[1, 5, 6]，因为是下标所以实际的数是：[2, 3, 4]
    11. 此时已经遍历结束，但还没算完，所以设置当遍历到最后一个数时，令i = -1代入进去，-1是根据题来的，
        根本的意思是：选择一个一定比数组里的任何数都小的数，将栈内剩余的数pop出栈，完成计算，更新最大面积变量
代码需要注意的点：
1. for循环要循环到heights.length，而不是length-1，因为最后要用一个绝对小的数将stack里剩余的数pop出来完成计算
2. 相同的数也要将其pop出来，即while循环的条件之一是 curNum <= heights[stack.peek()]
时间复杂度：O(N)
空间复杂度: O(N)，栈的最坏情况就是原数组也是单调递增的，那么栈会保存所有的数，再最后清算面积

为什么不能用DP？可以用，但时间复杂度不会有优化
可以使用DP，满足以下任意四个条件之一：
1. 求最大/最小
2. 判断是否可行
3. 计算方案个数
4. 暴力解法时间复杂度是指数级别，DP擅长将指数级(2^N，3^N，..)优化到多项式级别(N^2，N^3，..)
不可以使用DP，或者说使用DP不能进一步优化时间复杂度，满足以下任意三个条件之一：
1. 计算具体的方案(比如返回最短的路径[2, 3, 5]，而不是最短的路径有几个)
2. 输入的参数是一个无序集合(DP是通过找寻前后状态然后遍历整个序列计算最后的状态，如果是无序的集合，那么肯定没有前后状态)
3. 暴力解法的时间复杂度已经是多项式级别的，DP无法将已经是多项式级别的时间复杂度进一步优化

此题的暴力解法是O(N^2)，即对每一个数，再内循环一次找到其可能的最大宽度(向右遍历直到遇到第一个比自己小的数停止)
因为已经是多项式级别的时间复杂度了，DP不能将O(N^2)优化到更小，所以用DP也是O(N^2)，所以没什么用
 */

public class LargestRectangleInHistogram {
    public int solution(int[] heights) {
        Stack<Integer> stack = new Stack<>();
        int maxArea = 0;

        for (int i = 0; i <= heights.length; i++) {
            // if it's the last element,
            // assign a negative number to squeeze out remaining numbers in stack
            int curNum = i == heights.length ? -1 : heights[i];
            while (!stack.isEmpty() && curNum <= heights[stack.peek()]) {
                int height = heights[stack.pop()];
                int weight = stack.isEmpty() ? i : i - stack.peek() - 1;
                maxArea = Math.max(maxArea, height * weight);
            }
            stack.push(i);
        }
        return maxArea;
    }
}
