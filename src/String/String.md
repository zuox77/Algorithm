# String

## String的创建方式

### String有两种创建方式

#### 第一种

```
String s1 = "abc";
```

1. 在创建的时候, `JVM`会检查字符串常量池中是否已经存在该字符串
2. 如果存在, 则返回字符串常量池中该字符串的引用地址
3. 如果不存在, 则会先创建一个字符串常量池中的`abc`字符串对象, 再返回该字符串的引用地址

#### 第二种

```
String s2 = new String("abc");
```

需要把创建语句分为两块来看

1. `"abc"`: 与第一种类似, 先判断是否存在再字符串常量池中
    2. 如果存在, 则什么都不做
    3. 如果不存在, 则创造一个字符串常量池中的`abc`字符串对象
    4. 与第一种的区别在于, 这里并不会返回任何引用地址
2. `new String()`: 创造一个与字符串常量池中的`abc`一样的字符串对象, 不过这个对象会放在堆内存中, 而不是字符串常量池中

### 哪种更好

无论是官方推荐还是在实际项目中, 都最好使用第一种方法, 因为:

1. `String`类是一个被`final`所修饰的, 不可变的类, 即一旦一个`String`对象被创造出来, 那么该对象将一直存在, 直到被`GC`回收,
   就算对其进行修改更新, 也只会创建一个新的`String`对象
   所以如果使用了第二种方式`new String()`去创建`String`对象并存储信息, 当信息被更改后, 原信息仍会保留在内存中, 有泄漏的可能
2. 使用第一种方法, 每次都会创建出一个新的对象, 如果没有特殊情况需要多个内容一样的`String`对象, 那么会浪费内存

### 不同的创建方法组合起来使用的效果

```
// 程序初始化
String str1 = new String("java");
String str2 = "java";
String str3 = new String(str2);
String str4 = "java";
```

1. 创建`str1`: 因为程序刚初始化结束, 字符串常量池中没有`java`字符串, 所以按照第二种方法的步骤:
    1. 在字符串常量池中创建一个`String`对象, 其值(value)为`java`
    2. 在堆中创建一个`String`对象, 其值(value)为`java`
2. 创建`str2`: 因为在创建`str1`的过程中, 已经在字符串常量池创建了, 所以`str2`直接指向字符串常量池的引用地址
3. 创建`str3`: 同理, 因为字符串常量池已经有了, 所以只在堆中创建一个`String`对象, 其值(value)为`java`
    1. 注意: `str3`所代表的对象和`str1`所代表的对象, 并不是同一个对象
4. 创建`str4`: 因为在创建`str1`的过程中, 已经在字符串常量池创建了, 所以`str4`直接指向字符串常量池的引用地址
5. 其相互关系为:

```
// str1
str1 != str2 --> 因为str1对象指向堆的内存地址, str2对象指向字符串常量池的引用地址
str1 != str3 --> 因为str1和str3分别是堆内存中的两个不同对象
str1 != str4 --> 因为str4和str2是同一个对象, 都是指向字符串常量池的引用地址

// str2
str2 != str3 --> 因为str3对象指向堆的内存地址, str2对象指向字符串常量池的引用地址
str2 == str4 --> 因为str4和str2是同一个对象, 都是指向字符串常量池的引用地址

// str3
str3 != str4 --> 因为str3对象指向堆的内存地址, str2对象指向字符串常量池的引用地址
```

## 滑动窗口解法

https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/3982/hua-dong-chuang-kou-by-powcai/?orderBy=most_votes
