# Dynamic Programming 总结

## 前缀和与后缀和

### 普通前缀和与后缀和定义

#### 前缀和定义:

以下标`i`作为`结尾`的所有子数组的和  
即`prefix[i] = nums[0] + num[1] + nums[2] + ... + nums[i]`

#### 前缀和代码:

`prefix[i] = prefix[i - 1] + nums[i]`

```
例子:   [1, 3, -10, 2, -5, 2]
前缀和: [1, 4, -6, -4, -9, -7]
从左到右依次解释前缀和的数是怎么来的:
 1 = 1
 4 = 1 + 3
-6 = 1 + 3 + (-10)
-4 = 1 + 3 + (-10) + 2
以此类推
```

#### 后缀和定义:

以下标`i`作为`起始`的所有子数组的和
即`postfix[i] = nums[i] + num[i + 1] + nums[i + 2] + ... + nums[-1]`

#### 前缀和代码:

`postfix[i] = postfix[i + 1] + nums[i]`(注意这里是`i + 1`, 因为`i`是起始点, 即从右到左)

```
例子:   [1, 3, -10, 2, -5, 2]
后缀和: [-7, -8, -11, -1, -3, 2]
从右到左依次解释后缀和的数是怎么来的:
  2 = 2
 -3 = 2 + (-5)
 -1 = 2 + (-5) + 2
-11 = 2 + (-5) + 2 + (-10)
以此类推
```

### 变形前缀和与后缀和(自己随便取的名字), 本质是: 连续子数组的和的最大值

#### 变形前缀和 (leftMax) 定义:

以下标`i`作为`结尾`的任意连续子数组的和的最大值, 可以想象成一个不固定长度的滑动窗口, 只不过滑动窗口的`右边`固定为位置`i`

```
例子: [1, 3, -10, 2, -5, 2]
假设此时i = 3 (即数字2), 则以下标i作为结尾的任意连续子数组有:
[1, 3, -10, 2]
[3, -10, 2]
[-10, 2]
[2]
这些任意连续子数组的sum分别是:
[1, 3, -10, 2], sum = -4
[3, -10, 2],    sum = -5
[-10, 2],       sum = -8
[2],            sum =  2  --> 最大是2
所以leftMax[3] = 2
```

#### 变形前缀和 (leftMax) 代码: `leftMax[i] = Math.max(leftMax[i - 1] + nums[i], nums[i])`

```
例子: [1, 3, -10, 2, -5, 2]
前提条件: 假设此时i = 3 (即数字2)
目的: 想得知leftMax[3]的值
```

根据公式, 需要先知道`leftMax[i - 1]`的值

```
i - 1 = 2 (即数字-10), 则以下标i - 1作为结尾的任意连续子数组有:
[1, 3, -10], sum = -6 --> 最大是-6
[3, -10],    sum = -7
[-10],       sum = -10
所以leftMax[2] = -6
```

带入代码去理解:

```
leftMax[3] = Math.max(leftMax[2] + nums[3], nums[3])
即leftMax[3] = Math.max(-6 + 2, 2)
Math.max(-6 + 2, 2) = 2
所以leftMax[3] = 2
帮助理解: 如果上一个位置的数(即以i - 1为结尾的任意连续子数组的和的最大值, 如果还没有nums[i]大, 那么前面的数都不要了, 从i开始)
```

不用公式, 通过定义强行算,来检测一下:

```
假设此时i = 3 (即数字2), 则以下标i作为结尾的任意连续子数组以及它们的sum分别是:  
[1, 3, -10, 2], sum = -4
[3, -10, 2],    sum = -5
[-10, 2],       sum = -8
[2],            sum = 2  --> 最大是2
所以leftMax[3] = 2, 与上面公式算出来的吻合
```

#### 变形后缀和 (rightMax) 定义:

以下标`i`作为`起始`的任意连续子数组的和的最大值, 可以想象成一个不固定长度的滑动窗口, 只不过滑动窗口的`左边`固定为位置`i`

```
例子: [1, 3, -10, 2, -5, 2]
假设此时i = 2 (即数字-10), 则以下标i作为起始的任意连续子数组有:
[-10, 2, -5, 2]
[-10, 2, -5]
[-10, 2]
[-10]
这些任意连续子数组的sum分别是:
[-10, 2, -5, 2], sum = -11
[-10, 2, -5],    sum = -13
[-10, 2],        sum =  -8  --> 最大是-8
[-10],           sum = -10
所以rightMax[2] = -8
```

#### 变形后缀和 (rightMax) 代码: `rightMax[i] = Math.max(rightMax[i + 1] + nums[i], nums[i])`

```
例子: [1, 3, -10, 2, -5, 2]
前提条件: 假设此时i = 1 (即数字3)
目的: 想得知rightMax[1]的值
```

根据公式, 需要先知道`rightMax[i + 1]`的值

```
i + 1 = 2 (即数字-10), 则以下标i + 1作为起始的任意连续子数组有:
[-10, 2, -5, 2], sum = -11
[-10, 2, -5],    sum = -13
[-10, 2],        sum =  -8  --> 最大是-8
[-10],           sum = -10
所以rightMax[2] = -8
```

带入代码去理解:

```
rightMax[1] = Math.max(rightMax[2] + nums[1], nums[1])
即rightMax[1] = Math.max(-8 + 3, 3)
Math.max(-8 + 3, 3) = 3
所以rightMax[1] = 3
帮助理解: 如果下一个位置的数(即以i + 1为起始的任意连续子数组的和的最大值, 如果还没有nums[i]大, 那么后面的数都不要了, 从i开始)
```

不用公式, 通过定义强行算,来检测一下:

```
假设此时i = 1 (即数字3), 则以下标i作为起始的任意连续子数组以及它们的sum分别是:  
[3, -10, 2, -5, 2], sum =  -8
[3, -10, 2, -5],    sum = -10
[3, -10, 2],        sum =  -5
[3, -10],           sum =  -7
[3],                sum =   3  --> 最大是3
所以rightMax[1] = 3, 与上面公式算出来的吻合
```

### 最大前缀和与后缀和

#### 最大前缀和 (prefixMax) 定义:

以下标`i`作为`结尾`的任意连续子数组的和的`历史`最大值

#### 最大前缀和 (prefixMax) 代码: `prefixMax[i] = Math.max(leftMax[0], leftMax[1], ... , leftMax[i])`

```
例子: [1, 3, -10, 2, -5, 2]
假设此时i = 3 (即数字2), 那么

以下标3作为结尾的任意连续子数组有:
[1, 3, -10, 2]
[3, -10, 2]
[-10, 2]
[2]
这些任意连续子数组的sum分别是:
[1, 3, -10, 2], sum = -4
[3, -10, 2],    sum = -5
[-10, 2],       sum = -8
[2],            sum =  2  --> 最大是2, 即leftMax[3] = 2

以下标2作为结尾的任意连续子数组有:
[1, 3, -10]
[3, -10]
[-10]
这些任意连续子数组的sum分别是:
[1, 3, -10], sum =  -6  --> 最大是-6, 即leftMax[2] = -6
[3, -10],    sum =  -7
[-10],       sum = -10

以下标1作为结尾的任意连续子数组有:
[1, 3]
[3]
这些任意连续子数组的sum分别是:
[1, 3], sum = 4  --> 最大是4, 即leftMax[1] = 4
[3],    sum = 3

以下标0作为结尾的任意连续子数组有:
[1]
这些任意连续子数组的sum分别是:
[1],    sum = 1  --> 最大是1, 即leftMax[0] = 1

所以prefixMax[3] = Math.max(2, -6, 4, 1) = 4
```

#### 遍历一次求得最大前缀和 (prefixMax)

最大前缀和 (prefixMax) 一般是需要先算出来变形前缀和 (leftMax), 再遍历变形前缀和 (leftMax), 从而求得, 但也可以一次性完成

1. 本质其实是对求变形前缀和 (leftMax) 的代码做优化
2. 通过变形前缀和 (leftMax) 的公式可以发现, 其实`leftMax[i]`只和`leftMax[i - 1]`有关, 所以在计算 最大前缀和 (prefixMax)
   时, 其实我们不需要记录所有的值, 只需要记录上一次的值就可以
3. 这方法又称之为滚动空间

遍历一次得到最大前缀和代码:

```
public int solution(List<Integer> nums) {
    // 声明和定义
    List<Integer> prefixMax = new ArrayList<>(nums); // 相当于深度拷贝nums

    // 因为prefixMax只记录历史最大值, 所以需要一个变量记录上一次的值, 即leftMax[i - 1]
    int lastValue = nums.get(0);

    // 遍历
    for (int i = 0; i < nums.size(); i++) {
        // 计算当前最大值, 相当于在已知leftMax[i - 1]的情况下, 计算出leftMax[i]
        int currentValue = Math.max(lastValue + nums[i], nums[i]) // 这里就是求变形前缀和 (leftMax) 的公式
        // 计算prefixMax
        prefixMax[i] = Math.max(prefixMax[i - 1], currentValue);
        // 更新lastValue
        lastValue = currentValue;
    }
}
```

#### 最大后缀和 (postfixMax) 定义:

以下标`i`作为`起始`的任意连续子数组的和的`历史`最大值

#### 最大前缀和 (postfixMax) 代码: `postfixMax[i] = Math.max(rightMax[i], rightMax[i - 1], ... , rightMax[0])`

```
例子: [1, 3, -10, 2, -5, 2]
假设此时i = 3 (即数字2), 那么

以下标3作为结尾的任意连续子数组有:
[1, 3, -10, 2]
[3, -10, 2]
[-10, 2]
[2]
这些任意连续子数组的sum分别是:
[1, 3, -10, 2], sum = -4
[3, -10, 2],    sum = -5
[-10, 2],       sum = -8
[2],            sum =  2  --> 最大是2, 即rightMax[3] = 2

以下标2作为结尾的任意连续子数组有:
[1, 3, -10]
[3, -10]
[-10]
这些任意连续子数组的sum分别是:
[1, 3, -10], sum =  -6  --> 最大是-6, 即rightMax[2] = -6
[3, -10],    sum =  -7
[-10],       sum = -10

以下标1作为结尾的任意连续子数组有:
[1, 3]
[3]
这些任意连续子数组的sum分别是:
[1, 3], sum = 4  --> 最大是4, 即rightMax[1] = 4
[3],    sum = 3

以下标0作为结尾的任意连续子数组有:
[1]
这些任意连续子数组的sum分别是:
[1],    sum = 1  --> 最大是1, 即rightMax[0] = 1

所以postfixMax[3] = Math.max(2, -6, 4, 1) = 4
```

#### 遍历一次求得最大前缀和 (postfixMax)

最大前缀和 (postfixMax) 一般是需要先算出来变形前缀和 (rightMax), 再遍历变形前缀和 (rightMax), 从而求得, 但也可以一次性完成

1. 本质其实是对求变形前缀和 (rightMax) 的代码做优化
2. 通过变形前缀和 (rightMax) 的公式可以发现, 其实`rightMax[i]`只和`rightMax[i - 1]`有关, 所以在计算 最大前缀和 (
   postfixMax) 时, 其实我们不需要记录所有的值, 只需要记录上一次的值就可以
3. 这方法又称之为滚动空间

遍历一次得到最大前缀和代码:

```
public int solution(List<Integer> nums) {
    // nums长度
    int n = nums.size();

    // 声明和定义
    List<Integer> postfixMax = new ArrayList<>(nums); // 相当于深度拷贝nums

    // 因为postfixMax只记录历史最大值, 所以需要一个变量记录上一次的值, 即rightMax[i - 1]
    int lastValue = nums.get(n - 1); // 因为是以i为起始, 所以一般从右往左遍历, 所以初始化为nums的最后一个数

    // 遍历
    for (int i = n - 2; i >= 0; i--) {
        // 计算当前最大值, 相当于在已知rightMax[i + 1]的情况下, 计算出rightMax[i]
        int currentValue = Math.max(lastValue + nums[i], nums[i]) // 这里就是求变形前缀和 (rightMax) 的公式
        // 计算postfixMax
        postfixMax[i] = Math.max(postfixMax[i + 1], currentValue);
        // 更新lastValue
        lastValue = currentValue;
    }
}
```